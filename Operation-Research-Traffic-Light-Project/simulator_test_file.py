# -*- coding: utf-8 -*-
"""SIMULATOR TEST FILE

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Am5ObZSCYC1i53D5_Zz2Gfgsbwd5ZVzf
"""

#pip install simpy

"""# Simulator"""

#Queue/test data generator, run pip install simpy at start of every session
import simpy
import random
import queue 
import numpy as np
import pandas as pd

def arrival_process(env, rate,q):
      count = 0
      while True:
        interarrival = random.expovariate(rate) #for a poisson process,interarival time is a exponential distribution
        yield env.timeout(interarrival) #arrival event happens
        count += 1
        #print(f'arrival {count:3d} at time {env.now:5.1f}')#env.now gives current time of the clock
        q.append(str(round(env.now)))#arrival time rounded to interger, rounding will change makePedestrian(pQ,pflow),makeCar(cQ,cflow) slightly

class car(object):
  def __init__ (self, arrivalTime):
    self.arrival = arrivalTime
    self.loc = random.choice(['N','S','W','E'])
      
  def getWaitTime(self, crossTime):
    return crossTime - self.arrival
  
  def getArrivalTime(self):
    return self.arrival

  def getLocation(self):
    return self.loc
      
class pedestrian(object):
  def __init__ (self, arrivalTime):
    self.arrival = arrivalTime
    self.dir = random.choice(['V','H','D']) # vertical, horizontal, diagonal

  def getWaitTime(self, crossTime):
    return crossTime - self.arrival

  def getArrivalTime(self):
    return self.arrival
  
  def getDirection(self):
    return self.dir

###HELPER FOR CONVERTING TIMES TO OBJECTS####
# input: list of arrival times : pQueue , cQueue
# output: list of  typed objects : pFlow , cFlow

def makePedestrian(pQ,pflow): #input a queue of interger (or float) poisson arrival times, output a typed queue
  for i in range(len(pQ)): 
    t = int(pQ[i])  #change to float(pQ[i]) if arrival time is rounded to decimals 
    p = pedestrian(t)    
    pflow.append(p)
  return pflow

def makeCar(cQ,cflow):
  for i in range(len(cQ)):    
    t = int(cQ[i]) #change to float(cQ[i]) if arrival time is rounded to decimals 
    c = car(t)    
    cflow.append(c)
  return cflow

def updateCarWaitTime(Q, num, currSec, totalTime):
  carReactionTime = 2
  while not Q.empty() and num > 0:
    currCar = Q.get()
    totalTime += currCar.getWaitTime(currSec) + carReactionTime
    num -= 1
  return totalTime
  
def updatePpleWaitTime(Q, totalWaitTime, currSec):
  pplReactionTime = 1
  while not Q.empty():
    currPerson = Q.get()
    totalWaitTime += currPerson.getWaitTime(currSec) + pplReactionTime
  return totalWaitTime

# Inputs: 
#   pFlow: list of typed pedestrian
#   cFlow: list of typed car
#   lights: a 3-tuple of integers: (duration of green_horiz, duration of red_horiz, duration_all_red)
#   carRate: 2-tuple of (n,k) for a rate of n cars/ k seconds
#   minWalkTime: min time in seconds needed for a person to cross fully

# Outputs:
# Average wait time for car; people


def timeSimulator(pFlow, cFlow, lights, carRate, minWalkTime, totalTime):
  # make sure lights are realistic
  assert (minWalkTime <= lights[0])
  assert (minWalkTime <= lights[1])
  assert (minWalkTime <= lights[2])


  # initialize variables we need for the loop
  vertPplQ = queue.Queue()
  horizPplQ = queue.Queue()
  diagPplQ = queue.Queue() #ADDED
  NCarQ = queue.Queue()
  SCarQ = queue.Queue()
  ECarQ = queue.Queue()
  WCarQ = queue.Queue()

  currLight = 'greenHoriz'
  currLightTime = 0

  pplIndex = 0
  carIndex = 0

  totalPplWaitTime = 0
  totalCarWaitTime = 0

  # loop over time 
  for currSec in range(totalTime):

    # update people queues
    while pplIndex < len(pFlow) and currSec == pFlow[pplIndex].getArrivalTime():
      dir = pFlow[pplIndex].getDirection()
      if dir == 'V':
        vertPplQ.put(pFlow[pplIndex])
      elif dir == 'H':
        horizPplQ.put(pFlow[pplIndex])
      elif dir == 'D': #ADDED
        diagPplQ.put(pFlow[pplIndex])  #ADDED
      pplIndex += 1

    
    # update car queues
    while carIndex < len(cFlow) and currSec == cFlow[carIndex].getArrivalTime():
      loc = cFlow[carIndex].getLocation()
      if loc == 'N':
        NCarQ.put(cFlow[carIndex])
      elif loc == 'S':
        SCarQ.put(cFlow[carIndex])
      elif loc == 'E':
        ECarQ.put(cFlow[carIndex])
      else:
        WCarQ.put(cFlow[carIndex])
      carIndex += 1
    

    # check people and cars, update queues
    (carNum, carK) = carRate
    if currLight == 'greenHoriz':
      
      # pass cars for greenHoriz
      if currSec > 0 and currSec % carK == 0:
        totalCarWaitTime = updateCarWaitTime(ECarQ, carNum, currSec, totalCarWaitTime)
        totalCarWaitTime = updateCarWaitTime(WCarQ, carNum, currSec, totalCarWaitTime)

      # pass ppl for greenHoriz
      if currLightTime <=  lights[0] - minWalkTime:
        totalPplWaitTime = updatePpleWaitTime(horizPplQ, totalPplWaitTime, currSec)

        # pop off all diagonal people & add to vertical queue
        while not diagPplQ.empty():
          currDiagPerson = diagPplQ.get()
          vertPplQ.put(currDiagPerson)


    elif currLight == 'greenVert':

      # pass cars for greenVert
      if currSec > 0 and currSec % carK == 0:
        totalCarWaitTime = updateCarWaitTime(NCarQ, carNum, currSec, totalCarWaitTime)
        totalCarWaitTime = updateCarWaitTime(SCarQ, carNum, currSec, totalCarWaitTime)
 

      # pass ppl for greenVert
      if currLightTime <=  lights[1] - minWalkTime:
        totalPplWaitTime = updatePpleWaitTime(vertPplQ, totalPplWaitTime, currSec)

        # pop off all diagonal people & add to horizontal queue
        while not diagPplQ.empty():
          currDiagPerson = diagPplQ.get()
          horizPplQ.put(currDiagPerson)

    elif currLight == 'allRed':
      if currLightTime <=  lights[2] - minWalkTime:
        totalPplWaitTime = updatePpleWaitTime(horizPplQ, totalPplWaitTime, currSec)
        totalPplWaitTime = updatePpleWaitTime(vertPplQ, totalPplWaitTime, currSec)
        totalPplWaitTime = updatePpleWaitTime(diagPplQ, totalPplWaitTime, currSec)
 
    if currLight ==  'allRed':
      if currLightTime == lights[2]:
        currLight = 'greenHoriz'
        currLightTime = 0
      else:
        currLightTime += 1
    elif currLight == 'greenHoriz':
      if currLightTime == lights[0]:
        currLight = 'greenVert'
        currLightTime = 0
      else:
        currLightTime += 1
    elif currLight == 'greenVert':
      if currLightTime == lights[1]:
        currLight = 'allRed'
        currLightTime = 0
      else:
        currLightTime += 1

  avgCarWaitTime = totalCarWaitTime / len(cFlow)
  avgPplWaitTime = totalPplWaitTime / len(pFlow)

  return avgCarWaitTime, avgPplWaitTime

### TIME ADAPTIVE APPROACH ###

def timeSimulator_timeAdaptive(pFlow, cFlow, lights, carRate, minWalkTime, totalTime):
  # make sure lights are realistic
  assert (minWalkTime <= lights[0])
  assert (minWalkTime <= lights[1])
  assert (minWalkTime <= lights[2])


  # initialize variables we need for the loop
  vertPplQ = queue.Queue()
  horizPplQ = queue.Queue()
  diagPplQ = queue.Queue() #ADDED
  NCarQ = queue.Queue()
  SCarQ = queue.Queue()
  ECarQ = queue.Queue()
  WCarQ = queue.Queue()

  currLight = 'greenHoriz'
  currLightTime = 0
  flashing = False
  flashTime = 0

  pplIndex = 0
  carIndex = 0

  totalPplWaitTime = 0
  totalCarWaitTime = 0

  # loop over time 
  for currSec in range(totalTime):

    # update people queues
    while pplIndex < len(pFlow) and currSec == pFlow[pplIndex].getArrivalTime():
      dir = pFlow[pplIndex].getDirection()
      if dir == 'V':
        vertPplQ.put(pFlow[pplIndex])
      elif dir == 'H':
        horizPplQ.put(pFlow[pplIndex])
      elif dir == 'D': #ADDED
        diagPplQ.put(pFlow[pplIndex])  #ADDED
      pplIndex += 1

    
    # update car queues
    while carIndex < len(cFlow) and currSec == cFlow[carIndex].getArrivalTime():
      loc = cFlow[carIndex].getLocation()
      if loc == 'N':
        NCarQ.put(cFlow[carIndex])
      elif loc == 'S':
        SCarQ.put(cFlow[carIndex])
      elif loc == 'E':
        ECarQ.put(cFlow[carIndex])
      else:
        WCarQ.put(cFlow[carIndex])
      carIndex += 1
    

    # check people and cars, update queues
    (carNum, carK) = carRate
    if currLight == 'greenHoriz':
      
      # pass cars for greenHoriz
      if currSec > 0 and currSec % carK == 0:
        totalCarWaitTime = updateCarWaitTime(ECarQ, carNum, currSec, totalCarWaitTime)
        totalCarWaitTime = updateCarWaitTime(WCarQ, carNum, currSec, totalCarWaitTime)

      # pass ppl for greenHoriz
      if currLightTime <=  lights[0] - minWalkTime and not flashing:
        totalPplWaitTime = updatePpleWaitTime(horizPplQ, totalPplWaitTime, currSec)

        # pop off all diagonal people & add to vertical queue
        while not diagPplQ.empty():
          currDiagPerson = diagPplQ.get()
          vertPplQ.put(currDiagPerson)


    elif currLight == 'greenVert':

      # pass cars for greenVert
      if currSec > 0 and currSec % carK == 0:
        totalCarWaitTime = updateCarWaitTime(NCarQ, carNum, currSec, totalCarWaitTime)
        totalCarWaitTime = updateCarWaitTime(SCarQ, carNum, currSec, totalCarWaitTime)
 

      # pass ppl for greenVert
      if currLightTime <=  lights[1] - minWalkTime and not flashing:
        totalPplWaitTime = updatePpleWaitTime(vertPplQ, totalPplWaitTime, currSec)

        # pop off all diagonal people & add to horizontal queue
        while not diagPplQ.empty():
          currDiagPerson = diagPplQ.get()
          horizPplQ.put(currDiagPerson)

    elif currLight == 'allRed':
      if currLightTime <=  lights[2] - minWalkTime and not flashing:
        totalPplWaitTime = updatePpleWaitTime(horizPplQ, totalPplWaitTime, currSec)
        totalPplWaitTime = updatePpleWaitTime(vertPplQ, totalPplWaitTime, currSec)
        totalPplWaitTime = updatePpleWaitTime(diagPplQ, totalPplWaitTime, currSec)
    

    # adaptive version, careful comparing people & direction with cars
    totPpl = vertPplQ.qsize() + horizPplQ.qsize() + diagPplQ.qsize()
    totNSCar = NCarQ.qsize() + SCarQ.qsize()
    totEWCar = ECarQ.qsize() + WCarQ.qsize()
    totCar = totNSCar + totEWCar

    if currLight ==  'allRed':
      if currLightTime == lights[2] or flashTime == minWalkTime:
        currLight = 'greenHoriz'
        currLightTime = 0
        flashing = False
      elif currLightTime <= lights[2] - minWalkTime and totCar/(carNum/carK) > totPpl and flashing == False:
      #elif currLightTime <= lights[2] - minWalkTime and totCar> totPpl and flashing == False:
        flashing = True
        flashTime = 0
      else:
        currLightTime += 1
        flashTime += 1
    elif currLight == 'greenHoriz':
      if currLightTime == lights[0] or flashTime == minWalkTime:
        currLight = 'greenVert'
        currLightTime = 0
        flashing = False
      elif currLightTime <= lights[0] - minWalkTime and totNSCar/(carNum/carK) > totPpl/2 and flashing == False:
      #elif currLightTime <= lights[0] - minWalkTime and totNSCar > totEWCar and flashing == False:
        flashing = True
        flashTime = 0
      else:
        currLightTime += 1
        flashTime += 1
    elif currLight == 'greenVert':
      if currLightTime == lights[1] or flashTime == minWalkTime:
        currLight = 'allRed'
        currLightTime = 0
        flashing = False
      elif currLightTime <= lights[1] - minWalkTime and totCar/(carNum/carK) < totPpl and flashing == False:
      #elif currLightTime <= lights[1] - minWalkTime and totCar < totPpl and flashing == False:
        flashing = True
        flashTime = 0
      else:
        currLightTime += 1
        flashTime += 1



  avgCarWaitTime = totalCarWaitTime / len(cFlow)
  avgPplWaitTime = totalPplWaitTime / len(pFlow)

  return avgCarWaitTime, avgPplWaitTime

### LiGHT ORDER ADAPTIVE APPROACH ###

def timeSimulator_orderAdaptive(pFlow, cFlow, lights, carRate, minWalkTime, totalTime):
  # make sure lights are realistic
  assert (minWalkTime <= lights[0])
  assert (minWalkTime <= lights[1])
  assert (minWalkTime <= lights[2])


  # initialize variables we need for the loop
  vertPplQ = queue.Queue()
  horizPplQ = queue.Queue()
  diagPplQ = queue.Queue() #ADDED
  NCarQ = queue.Queue()
  SCarQ = queue.Queue()
  ECarQ = queue.Queue()
  WCarQ = queue.Queue()

  currLight = 'greenHoriz'
  currLightTime = 0

  pplIndex = 0
  carIndex = 0

  totalPplWaitTime = 0
  totalCarWaitTime = 0

  # loop over time 
  for currSec in range(totalTime):

    # update people queues
    while pplIndex < len(pFlow) and currSec == pFlow[pplIndex].getArrivalTime():
      dir = pFlow[pplIndex].getDirection()
      if dir == 'V':
        vertPplQ.put(pFlow[pplIndex])
      elif dir == 'H':
        horizPplQ.put(pFlow[pplIndex])
      elif dir == 'D': #ADDED
        diagPplQ.put(pFlow[pplIndex])  #ADDED
      pplIndex += 1

    
    # update car queues
    while carIndex < len(cFlow) and currSec == cFlow[carIndex].getArrivalTime():
      loc = cFlow[carIndex].getLocation()
      if loc == 'N':
        NCarQ.put(cFlow[carIndex])
      elif loc == 'S':
        SCarQ.put(cFlow[carIndex])
      elif loc == 'E':
        ECarQ.put(cFlow[carIndex])
      else:
        WCarQ.put(cFlow[carIndex])
      carIndex += 1
    

    # check people and cars, update queues
    (carNum, carK) = carRate
    if currLight == 'greenHoriz':
      
      # pass cars for greenHoriz
      if currSec > 0 and currSec % carK == 0:
        totalCarWaitTime = updateCarWaitTime(ECarQ, carNum, currSec, totalCarWaitTime)
        totalCarWaitTime = updateCarWaitTime(WCarQ, carNum, currSec, totalCarWaitTime)

      # pass ppl for greenHoriz
      if currLightTime <=  lights[0] - minWalkTime:
        totalPplWaitTime = updatePpleWaitTime(horizPplQ, totalPplWaitTime, currSec)

        # pop off all diagonal people & add to vertical queue
        while not diagPplQ.empty():
          currDiagPerson = diagPplQ.get()
          vertPplQ.put(currDiagPerson)


    elif currLight == 'greenVert':

      # pass cars for greenVert
      if currSec > 0 and currSec % carK == 0:
        totalCarWaitTime = updateCarWaitTime(NCarQ, carNum, currSec, totalCarWaitTime)
        totalCarWaitTime = updateCarWaitTime(SCarQ, carNum, currSec, totalCarWaitTime)
 

      # pass ppl for greenVert
      if currLightTime <=  lights[1] - minWalkTime:
        totalPplWaitTime = updatePpleWaitTime(vertPplQ, totalPplWaitTime, currSec)

        # pop off all diagonal people & add to horizontal queue
        while not diagPplQ.empty():
          currDiagPerson = diagPplQ.get()
          horizPplQ.put(currDiagPerson)

    elif currLight == 'allRed':
      if currLightTime <=  lights[2] - minWalkTime:
        totalPplWaitTime = updatePpleWaitTime(horizPplQ, totalPplWaitTime, currSec)
        totalPplWaitTime = updatePpleWaitTime(vertPplQ, totalPplWaitTime, currSec)
        totalPplWaitTime = updatePpleWaitTime(diagPplQ, totalPplWaitTime, currSec)
    

    # adaptive version, careful comparing people & direction with cars
    totPpl = vertPplQ.qsize() + horizPplQ.qsize() + diagPplQ.qsize()
    totNSCar = NCarQ.qsize() + SCarQ.qsize()
    totEWCar = ECarQ.qsize() + WCarQ.qsize()
    totCar = totNSCar + totEWCar

    #carFactor = minWalkTime/(carNum/carK)
    carFactor = carK/carNum
    state0Traffic = totEWCar*carFactor + totPpl/2
    state1Traffic = totNSCar*carFactor + totPpl/2
    #state0Traffic = totEWCar + totPpl/2
    #state1Traffic = totNSCar + totPpl/2
    state2Traffic = totPpl
    allTraffic = [state0Traffic, state1Traffic, state2Traffic]

    if currLight ==  'allRed':
      lightLength = lights[2]
    elif currLight == 'greenHoriz':
      lightLength = lights[0]
    elif currLight == 'greenVert':
      lightLength = lights[1]
    if currLightTime == lightLength:
      if state1Traffic > state0Traffic and state1Traffic > state2Traffic:
        currLight = 'greenVert'
      elif state0Traffic > state1Traffic and state0Traffic > state2Traffic:
        currLight = 'greenHoriz'
      else:
        currLight = 'allRed'
      currLightTime = 0
    else:
      currLightTime += 1



  avgCarWaitTime = totalCarWaitTime / len(cFlow)
  avgPplWaitTime = totalPplWaitTime / len(pFlow)

  return avgCarWaitTime, avgPplWaitTime

"""#Testing

## Condition Fixed Testing
"""

def repTesting(numIter, lights, carRate, minWalkTime, totalTime, carGenRate, pplGenRate):
  avgPplWaitLog = np.zeros(numIter)
  avgCarWaitLog = np.zeros(numIter)
  avgCarTimeAdaptLog = np.zeros(numIter)
  avgPplTimeAdaptLog = np.zeros(numIter)
  avgCarOrderAdaptLog = np.zeros(numIter)
  avgPplOrderAdaptLog = np.zeros(numIter)

  for i in range(numIter):
    # creates a SimPy Environment
    envCar = simpy.Environment()
    envP = simpy.Environment()

    # initializes a new arrival process connected to the Environment
    cQueue = [] #empty list to store arrival times
    pQueue = [] 
    arrivalsCar = arrival_process(envCar, carGenRate/60, cQueue) # rate 2 cars per minute (60s) would be 2/60
    arrivalsP = arrival_process(envP, pplGenRate/60, pQueue)  # rate 10 ppl per min would be 10/60

    # tell the Environment to process the first arrival Event,  aka. start the process!
    envCar.process(arrivalsCar)
    envP.process(arrivalsP)

    # run the Environment (stopping after t=1800; run for 30 minutes: 30 * 60s = 1800 s)
    envCar.run(until=totalTime)
    envP.run(until=totalTime)

    pFlow = []
    makePedestrian(pQueue,pFlow)
    cFlow = []
    makeCar(cQueue,cFlow)

    avgCarWaitTime, avgPplWaitTime = timeSimulator(pFlow, cFlow, lights, carRate, minWalkTime, totalTime)
    avgCarTimeAdapt, avgPplTimeAdapt = timeSimulator_timeAdaptive(pFlow, cFlow, lights, carRate, minWalkTime, totalTime)
    avgCarOrderAdapt, avgPplOrderAdapt = timeSimulator_orderAdaptive(pFlow, cFlow, lights, carRate, minWalkTime, totalTime)

    avgCarWaitLog[i] = avgCarWaitTime
    avgPplWaitLog[i] = avgPplWaitTime
    avgCarTimeAdaptLog[i] = avgCarTimeAdapt
    avgPplTimeAdaptLog[i] = avgPplTimeAdapt
    avgCarOrderAdaptLog[i] = avgCarOrderAdapt
    avgPplOrderAdaptLog[i] = avgPplOrderAdapt


  return ((avgCarWaitLog, avgPplWaitLog), (avgCarTimeAdaptLog, avgPplTimeAdaptLog), (avgCarOrderAdaptLog, avgPplOrderAdaptLog))

"""##Test All

### Numpy Implementation
"""

totalTime = 1800

numIter = 5 #50

minWalkTime = 10
lightsMin = 30
lights = [lightsMin + 30*i for i in range(4)]

carRate = (1,2) #one car every two seconds
carGenRateMin = 10 # cars per min
carGens = [carGenRateMin + 10*i for i in range(10)]

pplGenRateMin = 10 # ppl per min
pplGens = [carGenRateMin + 10*i for i in range(10)]

numLights = len(lights)
numCarGenRates = len(carGens)
numPplGenRates = len(pplGens)

def allTests():

  avgCarLog = np.zeros((numLights,numCarGenRates,numPplGenRates))
  avgPplLog = np.zeros((numLights,numCarGenRates,numPplGenRates))
  avgCarTimeAdaptLog = np.zeros((numLights,numCarGenRates,numPplGenRates))
  avgPplTimeAdaptLog = np.zeros((numLights,numCarGenRates,numPplGenRates))
  avgCarOrderAdaptLog = np.zeros((numLights,numCarGenRates,numPplGenRates))
  avgPplOrderAdaptLog = np.zeros((numLights,numCarGenRates,numPplGenRates))

  for l in range(numLights):
    for c in range(numCarGenRates):
      for p in range(numPplGenRates):
        lightTime = lights[l]
        allLights = [lightTime, lightTime, lightTime]
        ((avgCar, avgPpl), (avgCarTimeAdapt, avgPplTimeAdapt), (avgCarOrderAdapt, avgPplOrderAdapt)) = repTesting(numIter, allLights, carRate, minWalkTime, totalTime, carGens[c], pplGens[p])
        
        avgCarLog[l, c, p] = np.sum(avgCar)/numIter
        avgPplLog[l, c, p] = np.sum(avgPpl)/numIter
        avgCarTimeAdaptLog[l, c, p] = np.sum(avgCarTimeAdapt)/numIter
        avgPplTimeAdaptLog[l, c, p] = np.sum(avgPplTimeAdapt)/numIter
        avgCarOrderAdaptLog[l, c, p] = np.sum(avgCarOrderAdapt)/numIter
        avgPplOrderAdaptLog[l, c, p] = np.sum(avgPplOrderAdapt)/numIter
  
  return ((avgCarLog, avgPplLog), (avgCarTimeAdaptLog, avgPplTimeAdaptLog), (avgCarOrderAdaptLog, avgPplOrderAdaptLog))

"""### Pandas Implementation"""

import pandas as pd
totalTime = 1800
numIter = 5 
minWalkTime = 10
lightsMin = 30
lights = [lightsMin + 30*i for i in range(4)]
carRate = (1,2) #one car every two seconds
carGenRate = [(i+1) * 10 for i in range(10)] # cars per min
pplGenRate = [(i+1) * 10 for i in range(10)] # ppl per min
numLights = len(lights)
def makeTable(totalTime, numIter, minWalkTime, lightsMin, lights,carRate, carGenrate, pplGenRate,numLights):
  carL = []
  pplL = []
  carAdaptL = []
  pplAdaptL = []
  carOrderAdaptL = []
  pplOrderAdaptL = []
  lightL = []
  carGenRateL = []
  pplGenRateL = []

  for L in lights:
    for C in carGenRate:
      for P in pplGenRate:
        ((avgCar, avgPpl), (avgCarTimeAdapt, avgPplTimeAdapt), (avgCarOrderAdapt, avgPplOrderAdapt)) = repTesting(numIter, [L,L,L], carRate, minWalkTime, totalTime, C, P)
        carL.append(np.sum(avgCar)/numIter)
        pplL.append(np.sum(avgPpl)/numIter)
        carAdaptL.append(np.sum(avgCarTimeAdapt)/numIter)
        pplAdaptL.append(np.sum(avgPplTimeAdapt)/numIter)
        carOrderAdaptL.append(np.sum(avgCarOrderAdapt)/numIter)
        pplOrderAdaptL.append(np.sum(avgPplOrderAdapt)/numIter)
        lightL.append(L)
        carGenRateL.append(C)
        pplGenRateL.append(P)

  data = {"LIGHT_INTERVAL": lightL, 
          "CAR_GENERATED_RATE": carGenRateL,
          "PEOPLE_GENERATED_RATE": pplGenRateL, 
          "C_WAIT_TIME": carL, 
          "P_WAIT_TIME": pplL,
          "C_WAIT_TIME(ADAPT)": carAdaptL,
          "P_WAIT_TIME(ADAPT)": pplAdaptL,
          "C_WAIT_TIME(ORDER_ADAPT)": carOrderAdaptL,
          "P_WAIT_TIME(ORDER_ADAPT)":pplOrderAdaptL}
  df = pd.DataFrame (data, columns = ["LIGHT_INTERVAL","CAR_GENERATED_RATE","PEOPLE_GENERATED_RATE",
                                    "C_WAIT_TIME","P_WAIT_TIME","C_WAIT_TIME(ADAPT)","P_WAIT_TIME(ADAPT)","C_WAIT_TIME(ORDER_ADAPT)","P_WAIT_TIME(ORDER_ADAPT)"])
  return df

"""### Run Testing

### Numpy Testing
"""

((avgCarLog, avgPplLog), (avgCarTimeAdaptLog, avgPplTimeAdaptLog), (avgCarOrderAdaptLog, avgPplOrderAdaptLog)) = allTests()

avgCarLog = np.around(avgCarLog, 2)
avgPplLog = np.around(avgPplLog, 2)
avgCarTimeAdaptLog = np.around(avgCarTimeAdaptLog, 2)
avgPplTimeAdaptLog = np.around(avgPplTimeAdaptLog, 2)
avgCarOrderAdaptLog = np.around(avgCarOrderAdaptLog, 2)
avgPplOrderAdaptLog = np.around(avgPplOrderAdaptLog, 2)

(l,c,p) = np.shape(avgCarLog)
print((l,c,p))
allTables = [0] * l # list of tables, each table corresponds to a light length

for i in range(l):
  tab = [[0 for j in range(c)] for k in range(p)]
  for j in range(c):
    for k in range(p):
      tab[j][k] = (avgCarLog[i][j][k], avgCarTimeAdaptLog[i][j][k], avgCarOrderAdaptLog[i][j][k]), (avgPplLog[i][j][k], avgPplTimeAdaptLog[i][j][k], avgPplOrderAdaptLog[i][j][k])
  allTables[i] = tab

allDF = [0]*l
for i in range(l):
  allDF[i] = pd.DataFrame(allTables[i], columns = ['People Rate ' + str(pplGens[i]) for i in range(numPplGenRates)], index = ['Car Rate '+ str(carGens[i]) for i in range(numCarGenRates)])
  print(allDF[i])

"""### Pandas Testing"""

df = makeTable(totalTime, numIter, minWalkTime, lightsMin, lights,carRate, carGenRate, pplGenRate,numLights)

df

"""# Graph & Interpretation"""

import matplotlib.pyplot as plt
import seaborn as sns
def heatMap(lightInterval, waitTime):
  hmList = []
  df_interval = df[df["LIGHT_INTERVAL"] == lightInterval]
  for cr in df.CAR_GENERATED_RATE.unique():
    l = []
    for pr in df.PEOPLE_GENERATED_RATE.unique():
      dfcr = df_interval[df_interval["CAR_GENERATED_RATE"] == cr]
      dfprcr = (dfcr[dfcr["PEOPLE_GENERATED_RATE"] == pr]).reset_index()
      l.append(dfprcr[waitTime][0])
    #print(l)
    hmList.append(l)

  fig, ax = plt.subplots(figsize=(15,10))  
  x_axis_labels = [(i+1) * 10 for i in range(10)] 
  y_axis_labels = [(i+1) * 10 for i in range(10)] 
  if lightInterval < 90:
    if waitTime[0] == "P":
      sns.heatmap(hmList,annot = True, linewidths=.5,cmap="YlGnBu", ax=ax,
                  fmt='g', vmin=0, vmax=50, xticklabels=x_axis_labels, yticklabels=y_axis_labels)
    else:
      sns.heatmap(hmList,annot = True, linewidths=.5,cmap="YlGnBu", ax=ax,
                  fmt='g', vmin=0, vmax=225, xticklabels=x_axis_labels, yticklabels=y_axis_labels)
  else:
    if waitTime[0] == "P":
      sns.heatmap(hmList,annot = True, linewidths=.5,cmap="YlGnBu", ax=ax,
                  fmt='g', vmin=0, vmax=50, xticklabels=x_axis_labels, yticklabels=y_axis_labels)
    else:
      sns.heatmap(hmList,annot = True, linewidths=.5,cmap="YlGnBu", ax=ax,
                  fmt='g', vmin=0, vmax=225, xticklabels=x_axis_labels, yticklabels=y_axis_labels)
  ax.set_title(str(waitTime) + ' for light interval ' + str(lightInterval) + 's')
  plt.xlabel("People Gen Rate")
  plt.ylabel("Car Gen Rate")
  plt.show()

def heatMapAll (lightInerval):
  heatMap(lightInerval, "C_WAIT_TIME")
  heatMap(lightInerval, "C_WAIT_TIME(ORDER_ADAPT)")
  heatMap(lightInerval, "C_WAIT_TIME(ADAPT)")
  heatMap(lightInerval, "P_WAIT_TIME")
  heatMap(lightInerval, "P_WAIT_TIME(ORDER_ADAPT)")
  heatMap(lightInerval, "P_WAIT_TIME(ADAPT)")

heatMapAll(30)

heatMapAll(60)

heatMapAll(90)

heatMapAll(120)



"""# Find Corrolation"""

#Using Pearson Correlation
plt.figure(figsize=(12,10))
corr = df.corr()
mask = np.triu(np.ones_like(corr, dtype=bool))
sns.heatmap(corr, annot=True, cmap=plt.cm.Reds, mask=mask)
plt.show()

from sklearn import linear_model
X = df[["LIGHT_INTERVAL","CAR_GENERATED_RATE","PEOPLE_GENERATED_RATE"]]
Y = df[["C_WAIT_TIME"]]
regr = linear_model.LinearRegression()
regr.fit(X, Y)
print('Intercept: \n', regr.intercept_)
print('Coefficients: \n', regr.coef_)

print("predicted:", regr.predict([[1,0,0]]))

import statsmodels.api as sm
def linearRegression (y):
  X = df [["LIGHT_INTERVAL","CAR_GENERATED_RATE","PEOPLE_GENERATED_RATE"]]
  Y = df[[y]]
  X = sm.add_constant(X) # adding a constant
  model = sm.OLS(Y, X).fit()
  predictions = model.predict(X) 
 
  print_model = model.summary()
  print(print_model)

linearRegression ("C_WAIT_TIME") # linearly correlated with car generated rates
linearRegression ("C_WAIT_TIME(ORDER_ADAPT)") # linearly correlated with car generated rates(less correlated than normal and more correlated with pedestrians generated rate )
#above two are equally correlated with light interval

linearRegression ("C_WAIT_TIME(ADAPT)") # it is most linearly correlated with car generated rates, and not correlated with people generated rate, and negatively correlated with

linearRegression ("P_WAIT_TIME") # linear correlation with light interval; no correlation with car or people generated rate
linearRegression ("P_WAIT_TIME(ORDER_ADAPT)") # weak linear correlation with light interval; more postively correlated with car generated rate and negatively correlated with car generated rate
linearRegression ("P_WAIT_TIME(ADAPT)") #